#[derive(Debug)]
enum BoardPiece {
    Unmarked(u32),
    Marked(u32),
} 

struct Bingo {
    seq: Vec<u32>,
    boards: Vec<Board>,
}

#[derive(Debug)]
struct Board {
    pieces: Vec<Vec<BoardPiece>>,
}

struct Winner {
    value: u32, 
    sum: u32
}

impl Winner {
    fn new(value: u32, sum: u32) -> Self {
        Self {
            value,
            sum,
        }
    }

    fn calculate_result(&self) -> u32 {
        self.value * self.sum
    }
}

impl Iterator for Bingo {
    type Item = Winner;

    fn next(&mut self) -> Option<Self::Item> {
        for board in self.boards.into_iter() {
            if let Some(winner) = board.handle_next_value(*self.seq.iter().next().unwrap()) {
                return Some(winner);    
            }
        }
        None
    }
}

impl Board {
    fn new(pieces: Vec<Vec<BoardPiece>>) -> Self {
        Self {
            pieces
        }
    }

    fn handle_next_value(&mut self, value: u32) -> Option<Winner> {
        for row in 0..self.pieces.len() {
            for col in 0..self.pieces[row].len() {
                if let BoardPiece::Unmarked(inner) = self.pieces[row][col] {
                    if inner == value {
                        self.pieces[row][col] = BoardPiece::Marked(inner);
                        if let Some(sum) = self.check(row, col) {
                            return Some(Winner::new(value, sum));
                        }
                    }
                }
            }
        }
        None
    }

    fn check(&self, row: usize, col: usize) -> Option<u32> {
        let horizontal = self.pieces[row].iter()
            .fold(Vec::new(), |mut acc, piece| {
                if let BoardPiece::Marked(value) = piece {
                    acc.push(value);
                }
                acc
            });

        let vertical = self.pieces.iter()
            .fold(Vec::new(), |mut acc, row| {
                if let BoardPiece::Marked(value) = row[col] {
                    acc.push(value);
                }
                acc
            });

        if horizontal.iter().count() == 5{
            return Some(horizontal.iter().map(|v| **v).sum());
        } else if vertical.iter().count() == 5{
            return Some(vertical.iter().sum());
        }
        None
    }
}

impl Bingo {
    fn new(seq: Vec<u32>, boards: Vec<Board>) -> Self {
        Self {
            seq,
            boards,
        }
    }
}

pub fn handle_input(input: Vec<&str>) -> Option<()> {
    let seq: Vec<u32> = input.first()?
        .split(",")
        .map(|c| c.parse::<u32>().unwrap())
        .collect();
    
    let boards = parse_boards(input[1..].to_vec());
    let bingo = Bingo::new(seq, boards); 
    
    Some(())
}

fn parse_boards(input: Vec<&str>) -> Vec<Board> {
    let filtered = input.iter()
        .filter(|line| !line.is_empty())
        .collect::<Vec<_>>();

    let boards = filtered.chunks(5)
        .fold(Vec::new(), |mut acc, board| {
            let mut pieces = Vec::new();
            board.iter().for_each(|line| {
                pieces.push(line.split(" ")
                    .filter(|v| !v.is_empty())
                    .map(|v| {
                        BoardPiece::Unmarked(v.parse::<u32>().unwrap())
                    })
                    .collect::<Vec<_>>());
            });
            acc.push(Board::new(pieces));
            acc
        });
    boards
}
